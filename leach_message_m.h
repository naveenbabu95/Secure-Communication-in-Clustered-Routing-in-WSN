//
// Generated file, do not edit! Created by nedtool 4.6 from leach_message.msg.
//

#ifndef _LEACH_MESSAGE_M_H_
#define _LEACH_MESSAGE_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <map>
#include<string>
using namespace std;
typedef std::map<int, string> mapForData;
// }}

/**
 * Class generated from <tt>leach_message.msg:12</tt> by nedtool.
 * <pre>
 * message node2headMsg
 * {
 *     int source;
 *     int posX;
 *     int posY;
 *     bool die;
 *     double battery;
 *     string temperature;
 * }
 * </pre>
 */
class node2headMsg : public ::cMessage
{
  protected:
    int source_var;
    int posX_var;
    int posY_var;
    bool die_var;
    double battery_var;
    opp_string temperature_var;

  private:
    void copy(const node2headMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const node2headMsg&);

  public:
    node2headMsg(const char *name=NULL, int kind=0);
    node2headMsg(const node2headMsg& other);
    virtual ~node2headMsg();
    node2headMsg& operator=(const node2headMsg& other);
    virtual node2headMsg *dup() const {return new node2headMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getPosX() const;
    virtual void setPosX(int posX);
    virtual int getPosY() const;
    virtual void setPosY(int posY);
    virtual bool getDie() const;
    virtual void setDie(bool die);
    virtual double getBattery() const;
    virtual void setBattery(double battery);
    virtual const char * getTemperature() const;
    virtual void setTemperature(const char * temperature);
};

inline void doPacking(cCommBuffer *b, node2headMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, node2headMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>leach_message.msg:22</tt> by nedtool.
 * <pre>
 * message head2baseMsg
 * {
 *     bool die;
 *     int source;
 *     int posX;
 *     int posY;
 *     string mes;
 *     int dieCount;
 *     mapForData aggregatedData;
 *     double totalExpendedEnergy = 0.0;
 * }
 * </pre>
 */
class head2baseMsg : public ::cMessage
{
  protected:
    bool die_var;
    int source_var;
    int posX_var;
    int posY_var;
    opp_string mes_var;
    int dieCount_var;
    mapForData aggregatedData_var;
    double totalExpendedEnergy_var;

  private:
    void copy(const head2baseMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const head2baseMsg&);

  public:
    head2baseMsg(const char *name=NULL, int kind=0);
    head2baseMsg(const head2baseMsg& other);
    virtual ~head2baseMsg();
    head2baseMsg& operator=(const head2baseMsg& other);
    virtual head2baseMsg *dup() const {return new head2baseMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getDie() const;
    virtual void setDie(bool die);
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getPosX() const;
    virtual void setPosX(int posX);
    virtual int getPosY() const;
    virtual void setPosY(int posY);
    virtual const char * getMes() const;
    virtual void setMes(const char * mes);
    virtual int getDieCount() const;
    virtual void setDieCount(int dieCount);
    virtual mapForData& getAggregatedData();
    virtual const mapForData& getAggregatedData() const {return const_cast<head2baseMsg*>(this)->getAggregatedData();}
    virtual void setAggregatedData(const mapForData& aggregatedData);
    virtual double getTotalExpendedEnergy() const;
    virtual void setTotalExpendedEnergy(double totalExpendedEnergy);
};

inline void doPacking(cCommBuffer *b, head2baseMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, head2baseMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>leach_message.msg:34</tt> by nedtool.
 * <pre>
 * message broadcastMsg
 * {
 *     int posX;
 *     int posY;
 *     string color;
 *     string chFullPath;
 *     int CHNodeNo;
 * }
 * </pre>
 */
class broadcastMsg : public ::cMessage
{
  protected:
    int posX_var;
    int posY_var;
    opp_string color_var;
    opp_string chFullPath_var;
    int CHNodeNo_var;

  private:
    void copy(const broadcastMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const broadcastMsg&);

  public:
    broadcastMsg(const char *name=NULL, int kind=0);
    broadcastMsg(const broadcastMsg& other);
    virtual ~broadcastMsg();
    broadcastMsg& operator=(const broadcastMsg& other);
    virtual broadcastMsg *dup() const {return new broadcastMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPosX() const;
    virtual void setPosX(int posX);
    virtual int getPosY() const;
    virtual void setPosY(int posY);
    virtual const char * getColor() const;
    virtual void setColor(const char * color);
    virtual const char * getChFullPath() const;
    virtual void setChFullPath(const char * chFullPath);
    virtual int getCHNodeNo() const;
    virtual void setCHNodeNo(int CHNodeNo);
};

inline void doPacking(cCommBuffer *b, broadcastMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, broadcastMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>leach_message.msg:42</tt> by nedtool.
 * <pre>
 * message bsInitbroadcastMsg
 * {
 *     uint8_t publicKey[48];
 * }
 * </pre>
 */
class bsInitbroadcastMsg : public ::cMessage
{
  protected:
    uint8_t publicKey_var[48];

  private:
    void copy(const bsInitbroadcastMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const bsInitbroadcastMsg&);

  public:
    bsInitbroadcastMsg(const char *name=NULL, int kind=0);
    bsInitbroadcastMsg(const bsInitbroadcastMsg& other);
    virtual ~bsInitbroadcastMsg();
    bsInitbroadcastMsg& operator=(const bsInitbroadcastMsg& other);
    virtual bsInitbroadcastMsg *dup() const {return new bsInitbroadcastMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPublicKeyArraySize() const;
    virtual uint8_t getPublicKey(unsigned int k) const;
    virtual void setPublicKey(unsigned int k, uint8_t publicKey);
};

inline void doPacking(cCommBuffer *b, bsInitbroadcastMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, bsInitbroadcastMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>leach_message.msg:46</tt> by nedtool.
 * <pre>
 * message littleBroMsg
 * {
 *     int posX;
 *     int posY;
 *     int chNo;
 *     int chPosX;
 *     int chPosY;
 *     string chFullPath;
 *     string color;
 * }
 * </pre>
 */
class littleBroMsg : public ::cMessage
{
  protected:
    int posX_var;
    int posY_var;
    int chNo_var;
    int chPosX_var;
    int chPosY_var;
    opp_string chFullPath_var;
    opp_string color_var;

  private:
    void copy(const littleBroMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const littleBroMsg&);

  public:
    littleBroMsg(const char *name=NULL, int kind=0);
    littleBroMsg(const littleBroMsg& other);
    virtual ~littleBroMsg();
    littleBroMsg& operator=(const littleBroMsg& other);
    virtual littleBroMsg *dup() const {return new littleBroMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPosX() const;
    virtual void setPosX(int posX);
    virtual int getPosY() const;
    virtual void setPosY(int posY);
    virtual int getChNo() const;
    virtual void setChNo(int chNo);
    virtual int getChPosX() const;
    virtual void setChPosX(int chPosX);
    virtual int getChPosY() const;
    virtual void setChPosY(int chPosY);
    virtual const char * getChFullPath() const;
    virtual void setChFullPath(const char * chFullPath);
    virtual const char * getColor() const;
    virtual void setColor(const char * color);
};

inline void doPacking(cCommBuffer *b, littleBroMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, littleBroMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>leach_message.msg:57</tt> by nedtool.
 * <pre>
 * message Node2BaseMsg
 * {
 *     int source;
 *     int posX;
 *     int posY;
 *     double battery;
 *     string hash;
 *     string purpose;
 *     string timestamp;
 *     uint8_t nodepublickey[48];
 * }
 * </pre>
 */
class Node2BaseMsg : public ::cMessage
{
  protected:
    int source_var;
    int posX_var;
    int posY_var;
    double battery_var;
    opp_string hash_var;
    opp_string purpose_var;
    opp_string timestamp_var;
    uint8_t nodepublickey_var[48];

  private:
    void copy(const Node2BaseMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Node2BaseMsg&);

  public:
    Node2BaseMsg(const char *name=NULL, int kind=0);
    Node2BaseMsg(const Node2BaseMsg& other);
    virtual ~Node2BaseMsg();
    Node2BaseMsg& operator=(const Node2BaseMsg& other);
    virtual Node2BaseMsg *dup() const {return new Node2BaseMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getPosX() const;
    virtual void setPosX(int posX);
    virtual int getPosY() const;
    virtual void setPosY(int posY);
    virtual double getBattery() const;
    virtual void setBattery(double battery);
    virtual const char * getHash() const;
    virtual void setHash(const char * hash);
    virtual const char * getPurpose() const;
    virtual void setPurpose(const char * purpose);
    virtual const char * getTimestamp() const;
    virtual void setTimestamp(const char * timestamp);
    virtual unsigned int getNodepublickeyArraySize() const;
    virtual uint8_t getNodepublickey(unsigned int k) const;
    virtual void setNodepublickey(unsigned int k, uint8_t nodepublickey);
};

inline void doPacking(cCommBuffer *b, Node2BaseMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Node2BaseMsg& obj) {obj.parsimUnpack(b);}


#endif // ifndef _LEACH_MESSAGE_M_H_

